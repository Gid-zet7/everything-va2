// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    id           String  @id @default(cuid())
    emailAddress String  @unique
    firstName    String?
    lastName     String?
    imageUrl     String?

    stripeSubscriptionId String?             @unique
    stripeSubscription   StripeSubscription? @relation(fields: [stripeSubscriptionId], references: [id])

    role Role @default(user)

    accounts Account[]
    emailCategories EmailCategory[]
    emailRules EmailRule[]

    chatbotInteraction ChatbotInteraction?
}

enum Role {
    user
    admin
}

model ChatbotInteraction {
    id String @id @default(cuid())

    day   String
    count Int    @default(1)

    userId String? @unique
    user   User?   @relation(fields: [userId], references: [id])

    @@unique([day, userId])
    @@index([day, userId])
}

model StripeSubscription {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())

    userId String? @unique
    user   User?

    subscriptionId String? @unique
    productId      String?
    priceId        String?
    customerId     String?

    currentPeriodEnd DateTime
    updatedAt        DateTime @updatedAt
}

model Account {
    id     String @id @default(cuid())
    userId String

    binaryIndex Json?

    token        String @unique
    refreshToken String? // Add refresh token field
    tokenExpiresAt DateTime? // Add token expiration field
    provider     String
    emailAddress String
    name         String

    nextDeltaToken String?

    user           User           @relation(fields: [userId], references: [id])
    threads        Thread[]
    emailAddresses EmailAddress[]
    calendars      Calendar[]
}

//     // "dev": "next dev --turbo | egrep -v '^\\s?(GET|POST|OPTIONS)'",

model Thread {
    id              String   @id @default(cuid())
    subject         String
    lastMessageDate DateTime
    participantIds  String[]
    accountId       String
    account         Account  @relation(fields: [accountId], references: [id])

    done Boolean @default(false)

    inboxStatus Boolean @default(true)
    draftStatus Boolean @default(false)
    sentStatus  Boolean @default(false)

    emails Email[]

    @@index([accountId])
    @@index([done])
    @@index([inboxStatus])
    @@index([draftStatus])
    @@index([sentStatus])
    @@index([lastMessageDate])
}

model Email {
    id                   String                @id @default(cuid())
    threadId             String
    thread               Thread                @relation(fields: [threadId], references: [id])
    createdTime          DateTime
    lastModifiedTime     DateTime
    sentAt               DateTime
    receivedAt           DateTime
    internetMessageId    String
    subject              String
    sysLabels            String[]
    keywords             String[]
    sysClassifications   String[]
    sensitivity          Sensitivity           @default(normal)
    meetingMessageMethod MeetingMessageMethod?
    from                 EmailAddress          @relation("FromEmail", fields: [fromId], references: [id])
    fromId               String
    to                   EmailAddress[]        @relation("ToEmails")
    cc                   EmailAddress[]        @relation("CcEmails")
    bcc                  EmailAddress[]        @relation("BccEmails")
    replyTo              EmailAddress[]        @relation("ReplyToEmails")
    hasAttachments       Boolean
    body                 String?
    bodySnippet          String?
    attachments          EmailAttachment[]
    inReplyTo            String?
    references           String?
    threadIndex          String?
    internetHeaders      Json[]
    nativeProperties     Json?
    folderId             String?
    omitted              String[]

    emailLabel EmailLabel @default(inbox)
    
    // Organization relationships
    categoryId String?
    category   EmailCategory? @relation(fields: [categoryId], references: [id])
    classification EmailClassification?
    
    // Status tracking
    status EmailStatus @default(unread)
    priority EmailPriority @default(medium)
    
    // User-defined labels
    customLabels String[] @default([])
    
    // User notes
    notes String?

    @@index([threadId])
    @@index([emailLabel])
    @@index([sentAt])
    @@index([categoryId])
    @@index([status])
    @@index([priority])
}

enum EmailLabel {
    inbox
    sent
    draft
}

// New enums for email organization
enum EmailCategoryType {
    actionRequired
    waitingOn
    reference
    somedayLater
    clients
    projects
    finance
    meetings
    personal
    spam
}

enum EmailPriority {
    low
    medium
    high
    urgent
}

enum EmailStatus {
    unread
    read
    archived
    flagged
    snoozed
}

// New models for email organization
model EmailCategory {
    id          String   @id @default(cuid())
    name        String
    description String?
    color       String?  // Hex color for UI
    icon        String?  // Icon name for UI
    userId      String
    user        User     @relation(fields: [userId], references: [id])
    emails      Email[]
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    @@unique([userId, name])
    @@index([userId])
}

model EmailClassification {
    id           String   @id @default(cuid())
    emailId      String   @unique
    email        Email    @relation(fields: [emailId], references: [id])
    
    // AI classification results
    category     EmailCategoryType
    priority     EmailPriority
    confidence   Float    // 0.0 to 1.0 confidence score
    
    // Extracted entities
    entities     Json?    // Named entities (people, companies, dates, etc.)
    sentiment    String?  // positive, negative, neutral
    keywords     String[]
    
    // Action items
    hasActionItems    Boolean @default(false)
    actionItems       Json?   // Array of action items
    dueDate          DateTime?
    requiresResponse Boolean  @default(false)
    
    // Meeting detection
    isMeeting        Boolean @default(false)
    meetingDate      DateTime?
    meetingDuration  Int?    // in minutes
    
    // Client/Project detection
    clientName       String?
    projectName      String?
    
    createdAt        DateTime @default(now())
    updatedAt        DateTime @updatedAt

    @@index([priority])
    @@index([confidence])
}

model EmailRule {
    id          String   @id @default(cuid())
    name        String
    description String?
    userId      String
    user        User     @relation(fields: [userId], references: [id])
    
    // Rule conditions
    conditions  Json     // Array of conditions (from, to, subject, body, etc.)
    
    // Rule actions
    actions     Json     // Array of actions (categorize, label, priority, etc.)
    
    isActive    Boolean  @default(true)
    priority    Int      @default(0) // Higher number = higher priority
    
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    @@index([userId])
    @@index([isActive])
}

model EmailAddress {
    id            String  @id @default(cuid())
    name          String?
    address       String
    raw           String?
    sentEmails    Email[] @relation("FromEmail")
    receivedTo    Email[] @relation("ToEmails")
    receivedCc    Email[] @relation("CcEmails")
    receivedBcc   Email[] @relation("BccEmails")
    replyToEmails Email[] @relation("ReplyToEmails")

    accountId String
    account   Account @relation(fields: [accountId], references: [id])

    @@unique([accountId, address])
}

model EmailAttachment {
    id              String  @id @default(cuid())
    name            String
    mimeType        String
    size            Int
    inline          Boolean
    contentId       String?
    content         String?
    contentLocation String?
    Email           Email   @relation(fields: [emailId], references: [id])
    emailId         String
}

enum Sensitivity {
    normal
    private
    personal
    confidential
}

enum MeetingMessageMethod {
    request
    reply
    cancel
    counter
    other
}

// Calendar models
model Calendar {
    id          String   @id @default(cuid())
    accountId   String
    account     Account  @relation(fields: [accountId], references: [id])
    
    // Calendar details
    name        String
    description String?
    color       String?  // Hex color code
    isPrimary   Boolean  @default(false)
    isReadOnly  Boolean  @default(false)
    
    // Aurinko calendar ID
    aurinkoCalendarId String? @unique
    
    // Sync settings
    lastSyncAt  DateTime?
    syncEnabled Boolean  @default(true)
    
    events      CalendarEvent[]
    
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    @@index([accountId])
    @@index([isPrimary])
}

model CalendarEvent {
    id          String   @id @default(cuid())
    calendarId  String
    calendar    Calendar @relation(fields: [calendarId], references: [id])
    
    // Event details
    title       String
    description String?
    location    String?
    
    // Time details
    startTime   DateTime
    endTime     DateTime
    isAllDay    Boolean  @default(false)
    
    // Recurrence
    recurrence  Json?    // Recurrence pattern (RRULE format)
    
    // Attendees
    attendees   Json?    // Array of attendee objects
    
    // Status
    status      CalendarEventStatus @default(confirmed)
    
    // Aurinko event ID
    aurinkoEventId String? @unique
    
    // Meeting link (for online meetings)
    meetingUrl  String?
    
    // Reminders
    reminders   Json?    // Array of reminder objects
    
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    @@index([calendarId])
    @@index([startTime])
    @@index([endTime])
    @@index([status])
}

enum CalendarEventStatus {
    confirmed
    tentative
    cancelled
    needsAction
}
